// Code generated by eugene. DO NOT EDIT.
package {{ .Package }}

import (
{{- if .Features.HasStreaming }}
	"bufio"
{{- end }}
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
{{- if .Features.HasMultipart }}
	"mime/multipart"
{{- end }}
	"net/http"
{{- if or .Features.HasQueryParams .Features.HasQueryString .Features.HasFormUrlEncoded }}
	"net/url"
{{- end }}
	"strings"
)

type Client struct {
	baseURL    string
	httpClient *http.Client
}

type ClientOption func(*Client)

func WithHTTPClient(client *http.Client) ClientOption {
	return func(c *Client) {
		c.httpClient = client
	}
}

func NewClient(baseURL string, opts ...ClientOption) *Client {
	c := &Client{
		baseURL:    strings.TrimSuffix(baseURL, "/"),
		httpClient: http.DefaultClient,
	}
	for _, opt := range opts {
		opt(c)
	}
	return c
}

type Response[T any] struct {
	StatusCode int
	Body       T
	Raw        *http.Response
}
{{- if .Features.HasMultipart }}

type FileUpload struct {
	Reader   io.Reader
	Filename string
}
{{- end }}
{{- if .Features.HasQueryString }}

func encodeQueryString(v any) string {
	q := url.Values{}
	encodeValue(q, "", v)
	return q.Encode()
}

func encodeValue(q url.Values, prefix string, v any) {
	switch val := v.(type) {
	case nil:
		return
	case string:
		q.Set(prefix, val)
	case int, int32, int64, float32, float64, bool:
		q.Set(prefix, fmt.Sprint(val))
	case []any:
		for i, item := range val {
			key := prefix
			if prefix != "" {
				key = fmt.Sprintf("%s[%d]", prefix, i)
			}
			encodeValue(q, key, item)
		}
	case map[string]any:
		for k, item := range val {
			key := k
			if prefix != "" {
				key = fmt.Sprintf("%s[%s]", prefix, k)
			}
			encodeValue(q, key, item)
		}
	default:
		q.Set(prefix, fmt.Sprint(val))
	}
}
{{- end }}
{{- if .Features.HasStreaming }}

// ServerEvent represents a Server-Sent Event.
type ServerEvent struct {
	Type string // event type from "event:" field
	Data []byte // event data from "data:" field
	ID   string // event ID from "id:" field
}

// Decode unmarshals the event data into the provided value.
func (e *ServerEvent) Decode(v any) error {
	return json.Unmarshal(e.Data, v)
}

// EventStream reads Server-Sent Events from an HTTP response.
// Use Next() to advance, Current() to get the event, Err() to check errors.
type EventStream struct {
	resp    *http.Response
	scanner *bufio.Scanner
	current *ServerEvent
	err     error
}

func newEventStream(resp *http.Response) *EventStream {
	return &EventStream{
		resp:    resp,
		scanner: bufio.NewScanner(resp.Body),
	}
}

// Next advances to the next event. Returns false when stream ends or on error.
func (s *EventStream) Next() bool {
	if s.err != nil {
		return false
	}

	event := &ServerEvent{}
	var data []byte

	for s.scanner.Scan() {
		line := s.scanner.Bytes()

		if len(line) == 0 {
			// Empty line = end of event
			if len(data) > 0 {
				event.Data = bytes.TrimSuffix(data, []byte("\n"))
				s.current = event
				return true
			}
			continue
		}

		switch {
		case bytes.HasPrefix(line, []byte("event:")):
			event.Type = string(bytes.TrimSpace(line[6:]))
		case bytes.HasPrefix(line, []byte("data:")):
			data = append(data, bytes.TrimSpace(line[5:])...)
			data = append(data, '\n')
		case bytes.HasPrefix(line, []byte("id:")):
			event.ID = string(bytes.TrimSpace(line[3:]))
		}
	}

	// Handle final event without trailing newline
	if len(data) > 0 {
		event.Data = bytes.TrimSuffix(data, []byte("\n"))
		s.current = event
		return true
	}

	s.err = s.scanner.Err()
	return false
}

// Current returns the most recent event from Next().
func (s *EventStream) Current() *ServerEvent {
	return s.current
}

// Err returns the error that stopped iteration, if any.
// Returns nil on normal EOF.
func (s *EventStream) Err() error {
	return s.err
}

// Close closes the underlying response body.
func (s *EventStream) Close() error {
	return s.resp.Body.Close()
}

func doStreamRequest(ctx context.Context, c *Client, method, path string, body any) (*EventStream, error) {
	var bodyReader io.Reader
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("marshaling request body: %w", err)
		}
		bodyReader = bytes.NewReader(data)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	req.Header.Set("Accept", "text/event-stream")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}

	if resp.StatusCode >= 400 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return newEventStream(resp), nil
}
{{- end }}

func doRequest[T any](ctx context.Context, c *Client, method, path string, body any) (*Response[T], error) {
	var bodyReader io.Reader
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("marshaling request body: %w", err)
		}
		bodyReader = bytes.NewReader(data)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &Response[T]{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	if resp.StatusCode >= 400 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	if resp.ContentLength != 0 {
		if err := json.NewDecoder(resp.Body).Decode(&result.Body); err != nil && err != io.EOF {
			return result, fmt.Errorf("decoding response: %w", err)
		}
	}

	return result, nil
}
{{- range .Operations }}
{{- if not .IsStreaming }}

// {{ .ID | pascalCase }}Response contains typed response data for {{ .ID | pascalCase }}.
type {{ .ID | pascalCase }}Response struct {
	StatusCode int
{{- range .Responses }}
{{- if eq .StatusCode "default" }}
	JSONDefault *{{ if .Type }}{{ .Type }}{{ else }}struct{}{{ end }}
{{- else }}
	JSON{{ .StatusCode | statusCodeInt }} *{{ if .Type }}{{ .Type }}{{ else }}struct{}{{ end }}
{{- end }}
{{- end }}
	Raw *http.Response
}
{{- end }}
{{- if .IsMultipart }}

// {{ .ID | pascalCase }}Request is the multipart request for {{ .ID | pascalCase }}.
type {{ .ID | pascalCase }}Request struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }}
{{- end }}
}
{{- end }}
{{- if .IsFormUrlEncoded }}

// {{ .ID | pascalCase }}Request is the form-urlencoded request for {{ .ID | pascalCase }}.
type {{ .ID | pascalCase }}Request struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }}
{{- end }}
}
{{- end }}
{{- end }}
{{ range .Operations }}
{{- if .IsStreaming }}
{{ if .Summary }}// {{ .ID | pascalCase }} - {{ .Summary }} (streaming){{ end }}
func (c *Client) {{ .ID | pascalCase }}(ctx context.Context{{ range .PathParams }}, {{ .GoName | lower }} {{ .Type }}{{ end }}{{ if .HasBody }}, body {{ .RequestBody.Type }}{{ end }}{{ if .HasQueryParams }}, params *{{ .ID | pascalCase }}Params{{ end }}{{ if .HasQueryString }}, query *{{ .QueryStringParam.Type }}{{ end }}) (*EventStream, error) {
	path := "{{ .Path }}"
{{- range .PathParams }}
	path = strings.Replace(path, "{{"{"}}{{ .Name }}{{"}"}}", fmt.Sprint({{ .GoName | lower }}), 1)
{{- end }}
{{- if .HasQueryParams }}
	if params != nil {
		q := url.Values{}
{{- range .QueryParams }}
{{- if .Required }}
		q.Set("{{ .Name }}", fmt.Sprint(params.{{ .GoName }}))
{{- else }}
		if params.{{ .GoName }} != nil {
			q.Set("{{ .Name }}", fmt.Sprint(*params.{{ .GoName }}))
		}
{{- end }}
{{- end }}
		if len(q) > 0 {
			path += "?" + q.Encode()
		}
	}
{{- end }}
{{- if .HasQueryString }}
	if query != nil {
		path += "?" + encodeQueryString(query)
	}
{{- end }}
	return doStreamRequest(ctx, c, "{{ .Method }}", path{{ if .HasBody }}, body{{ else }}, nil{{ end }})
}
{{- else }}
{{ if .Summary }}// {{ .ID | pascalCase }} - {{ .Summary }}{{ end }}
func (c *Client) {{ .ID | pascalCase }}(ctx context.Context{{ range .PathParams }}, {{ .GoName | lower }} {{ .Type }}{{ end }}{{ if and .HasBody (not .IsMultipart) (not .IsFormUrlEncoded) }}, body {{ .RequestBody.Type }}{{ end }}{{ if .IsMultipart }}, req {{ .ID | pascalCase }}Request{{ end }}{{ if .IsFormUrlEncoded }}, req {{ .ID | pascalCase }}Request{{ end }}{{ if .HasQueryParams }}, params *{{ .ID | pascalCase }}Params{{ end }}{{ if .HasQueryString }}, query *{{ .QueryStringParam.Type }}{{ end }}) (*{{ .ID | pascalCase }}Response, error) {
	path := "{{ .Path }}"
{{- range .PathParams }}
	path = strings.Replace(path, "{{"{"}}{{ .Name }}{{"}"}}", fmt.Sprint({{ .GoName | lower }}), 1)
{{- end }}
{{- if .HasQueryParams }}
	if params != nil {
		q := url.Values{}
{{- range .QueryParams }}
{{- if .Required }}
		q.Set("{{ .Name }}", fmt.Sprint(params.{{ .GoName }}))
{{- else }}
		if params.{{ .GoName }} != nil {
			q.Set("{{ .Name }}", fmt.Sprint(*params.{{ .GoName }}))
		}
{{- end }}
{{- end }}
		if len(q) > 0 {
			path += "?" + q.Encode()
		}
	}
{{- end }}
{{- if .HasQueryString }}
	if query != nil {
		path += "?" + encodeQueryString(query)
	}
{{- end }}

	var bodyReader io.Reader
{{- if or .HasBody .IsMultipart .IsFormUrlEncoded }}
	var contentType string
{{- end }}
{{- if .IsMultipart }}
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
{{- range .RequestBody.MultipartFields }}
{{- if .IsFile }}
{{- if .IsArray }}
	for i, file := range req.{{ .GoName }} {
		if file != nil {
			part, err := writer.CreateFormFile("{{ .Name }}", file.Filename)
			if err != nil {
				return nil, fmt.Errorf("creating form file {{ .Name }}[%d]: %w", i, err)
			}
			if _, err := io.Copy(part, file.Reader); err != nil {
				return nil, fmt.Errorf("writing file {{ .Name }}[%d]: %w", i, err)
			}
		}
	}
{{- else }}
	if req.{{ .GoName }} != nil {
		part, err := writer.CreateFormFile("{{ .Name }}", req.{{ .GoName }}.Filename)
		if err != nil {
			return nil, fmt.Errorf("creating form file {{ .Name }}: %w", err)
		}
		if _, err := io.Copy(part, req.{{ .GoName }}.Reader); err != nil {
			return nil, fmt.Errorf("writing file {{ .Name }}: %w", err)
		}
	}
{{- end }}
{{- else if .IsArray }}
	for _, v := range req.{{ .GoName }} {
		if err := writer.WriteField("{{ .Name }}", v); err != nil {
			return nil, fmt.Errorf("writing field {{ .Name }}: %w", err)
		}
	}
{{- else }}
	if req.{{ .GoName }} != "" {
		if err := writer.WriteField("{{ .Name }}", req.{{ .GoName }}); err != nil {
			return nil, fmt.Errorf("writing field {{ .Name }}: %w", err)
		}
	}
{{- end }}
{{- end }}
	if err := writer.Close(); err != nil {
		return nil, fmt.Errorf("closing multipart writer: %w", err)
	}
	bodyReader = body
	contentType = writer.FormDataContentType()
{{- else if .IsFormUrlEncoded }}
	formData := url.Values{}
{{- range .RequestBody.MultipartFields }}
{{- if .IsArray }}
	for _, v := range req.{{ .GoName }} {
		formData.Add("{{ .Name }}", v)
	}
{{- else }}
	if req.{{ .GoName }} != "" {
		formData.Set("{{ .Name }}", req.{{ .GoName }})
	}
{{- end }}
{{- end }}
	bodyReader = strings.NewReader(formData.Encode())
	contentType = "application/x-www-form-urlencoded"
{{- else if .HasBody }}
	data, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshaling request body: %w", err)
	}
	bodyReader = bytes.NewReader(data)
	contentType = "application/json"
{{- end }}

	httpReq, err := http.NewRequestWithContext(ctx, "{{ .Method }}", c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}
{{- if or .HasBody .IsMultipart .IsFormUrlEncoded }}
	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}
{{- end }}
	httpReq.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &{{ .ID | pascalCase }}Response{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, fmt.Errorf("reading response: %w", err)
	}

	switch resp.StatusCode {
{{- range .Responses }}
{{- if eq .StatusCode "default" }}
	default:
{{- if .Type }}
		var body {{ .Type }}
		if len(bodyBytes) > 0 {
			if err := json.Unmarshal(bodyBytes, &body); err != nil {
				return result, fmt.Errorf("decoding response: %w", err)
			}
		}
		result.JSONDefault = &body
{{- end }}
{{- else }}
	case {{ .StatusCode | statusCodeInt }}:
{{- if .Type }}
		var body {{ .Type }}
		if len(bodyBytes) > 0 {
			if err := json.Unmarshal(bodyBytes, &body); err != nil {
				return result, fmt.Errorf("decoding response: %w", err)
			}
		}
		result.JSON{{ .StatusCode | statusCodeInt }} = &body
{{- end }}
{{- end }}
{{- end }}
	}

	if resp.StatusCode >= 400 {
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return result, nil
}
{{- end }}
{{ end }}
{{- range .Operations }}
{{- if .HasQueryParams }}

type {{ .ID | pascalCase }}Params struct {
{{- range .QueryParams }}
{{- if .Required }}
	{{ .GoName }} {{ .Type }}
{{- else }}
	{{ .GoName }} *{{ .Type }}
{{- end }}
{{- end }}
}
{{- end }}
{{- end }}
