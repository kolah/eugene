// Code generated by eugene. DO NOT EDIT.
package {{ .Package }}

import (
{{- if .Features.HasCallbacks }}
	"bytes"
	"context"
{{- end }}
{{- if or .Features.HasStreaming .Features.HasQueryString .Features.HasCallbacks }}
	"encoding/json"
{{- end }}
{{- if or .Features.HasStreaming .Features.HasCallbacks }}
	"fmt"
{{- end }}
{{- if .Features.HasMultipart }}
	"mime/multipart"
{{- end }}
	"net/http"

	"github.com/go-chi/chi/v5"
)
{{- if .Features.HasStreaming }}

// Writer writes Server-Sent Events to an HTTP response.
type Writer struct {
	w       http.ResponseWriter
	flusher http.Flusher
}

// NewWriter creates a Writer from an http.ResponseWriter.
func NewWriter(w http.ResponseWriter) (*Writer, error) {
	flusher, ok := w.(http.Flusher)
	if !ok {
		return nil, fmt.Errorf("streaming not supported")
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	return &Writer{w: w, flusher: flusher}, nil
}

// Send writes an event with optional type. Data is JSON-encoded.
func (w *Writer) Send(eventType string, data any) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return w.SendRaw(eventType, jsonData)
}

// SendRaw writes raw data without JSON encoding.
func (w *Writer) SendRaw(eventType string, data []byte) error {
	if eventType != "" {
		if _, err := fmt.Fprintf(w.w, "event: %s\n", eventType); err != nil {
			return err
		}
	}
	if _, err := fmt.Fprintf(w.w, "data: %s\n\n", data); err != nil {
		return err
	}
	w.flusher.Flush()
	return nil
}
{{- end }}
{{- range .Operations }}
{{- if .IsMultipart }}

type {{ .ID | pascalCase }}MultipartRequest struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }} `form:"{{ .Name }}"`
{{- end }}
}
{{- end }}
{{- if .IsFormUrlEncoded }}

type {{ .ID | pascalCase }}FormRequest struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }} `form:"{{ .Name }}"`
{{- end }}
}
{{- end }}
{{- end }}

type ServerInterface interface {
{{- range .Operations }}
	// {{ .ID | pascalCase }}{{ if .Summary }} - {{ .Summary }}{{ end }}{{ if .IsStreaming }} (streaming){{ end }}
	{{ .ID | pascalCase }}(w http.ResponseWriter, r *http.Request{{ range .Parameters }}{{ if eq .In "path" }}, {{ .GoName | lower }} {{ .Type }}{{ end }}{{ end }}{{ if .HasQueryString }}, {{ .QueryString.GoName | lower }} *{{ .QueryString.Type }}{{ end }}{{ if .IsMultipart }}, req {{ .ID | pascalCase }}MultipartRequest{{ end }}{{ if .IsFormUrlEncoded }}, req {{ .ID | pascalCase }}FormRequest{{ end }})
{{- end }}
}

type ServerInterfaceWrapper struct {
	Handler ServerInterface
}
{{ range .Operations }}
func (w *ServerInterfaceWrapper) {{ .ID | pascalCase }}(rw http.ResponseWriter, r *http.Request) {
{{- range .Parameters }}
{{- if eq .In "path" }}
	{{ .GoName | lower }} := chi.URLParam(r, "{{ .Name }}")
{{- end }}
{{- end }}
{{- if .HasQueryString }}
	var {{ .QueryString.GoName | lower }} {{ .QueryString.Type }}
	if err := decodeQueryString(r, &{{ .QueryString.GoName | lower }}); err != nil {
		http.Error(rw, "invalid query parameters", http.StatusBadRequest)
		return
	}
{{- end }}
{{- if .IsMultipart }}
	var req {{ .ID | pascalCase }}MultipartRequest
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		http.Error(rw, "failed to parse multipart form", http.StatusBadRequest)
		return
	}
{{- range .RequestBody.MultipartFields }}
{{- if .IsFile }}
{{- if .IsArray }}
	if r.MultipartForm != nil && r.MultipartForm.File != nil {
		req.{{ .GoName }} = r.MultipartForm.File["{{ .Name }}"]
	}
{{- else }}
	if r.MultipartForm != nil && r.MultipartForm.File != nil {
		if files := r.MultipartForm.File["{{ .Name }}"]; len(files) > 0 {
			req.{{ .GoName }} = files[0]
		}
	}
{{- end }}
{{- else if .IsArray }}
	if r.MultipartForm != nil && r.MultipartForm.Value != nil {
		req.{{ .GoName }} = r.MultipartForm.Value["{{ .Name }}"]
	}
{{- else }}
	req.{{ .GoName }} = r.FormValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- end }}
{{- if .IsFormUrlEncoded }}
	var req {{ .ID | pascalCase }}FormRequest
	if err := r.ParseForm(); err != nil {
		http.Error(rw, "failed to parse form", http.StatusBadRequest)
		return
	}
{{- range .RequestBody.MultipartFields }}
{{- if .IsArray }}
	req.{{ .GoName }} = r.Form["{{ .Name }}"]
{{- else }}
	req.{{ .GoName }} = r.FormValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- end }}
	w.Handler.{{ .ID | pascalCase }}(rw, r{{ range .Parameters }}{{ if eq .In "path" }}, {{ .GoName | lower }}{{ end }}{{ end }}{{ if .HasQueryString }}, &{{ .QueryString.GoName | lower }}{{ end }}{{ if .IsMultipart }}, req{{ end }}{{ if .IsFormUrlEncoded }}, req{{ end }})
}
{{ end }}
{{- if .Features.HasQueryString }}
func decodeQueryString(r *http.Request, v any) error {
	data := make(map[string]any)
	for key, values := range r.URL.Query() {
		if len(values) == 1 {
			data[key] = values[0]
		} else {
			data[key] = values
		}
	}
	b, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, v)
}
{{- end }}

func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL    string
	Middlewares []func(http.Handler) http.Handler
}

func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := chi.NewRouter()

	for _, m := range options.Middlewares {
		r.Use(m)
	}

	wrapper := &ServerInterfaceWrapper{Handler: si}
{{ range .Operations }}
	r.Method("{{ .Method }}", options.BaseURL+"{{ .FramePath }}", http.HandlerFunc(wrapper.{{ .ID | pascalCase }}))
{{- end }}

	return r
}
{{- if .Features.HasCallbacks }}

// CallbackServerInterface handles incoming callback requests.
// Implement this interface for webhook endpoints that receive callbacks.
type CallbackServerInterface interface {
{{- range .Callbacks }}
	// {{ .GoName }} handles the {{ .Name }} callback
	{{ .GoName }}(w http.ResponseWriter, r *http.Request)
{{- end }}
}

type CallbackServerInterfaceWrapper struct {
	Handler CallbackServerInterface
}
{{ range .Callbacks }}
func (w *CallbackServerInterfaceWrapper) {{ .GoName }}(rw http.ResponseWriter, r *http.Request) {
	w.Handler.{{ .GoName }}(rw, r)
}
{{ end }}
func CallbackHandler(si CallbackServerInterface) http.Handler {
	return CallbackHandlerWithOptions(si, ChiCallbackServerOptions{})
}

type ChiCallbackServerOptions struct {
	BaseURL     string
	Middlewares []func(http.Handler) http.Handler
}

func CallbackHandlerWithOptions(si CallbackServerInterface, options ChiCallbackServerOptions) http.Handler {
	r := chi.NewRouter()

	for _, m := range options.Middlewares {
		r.Use(m)
	}

	wrapper := &CallbackServerInterfaceWrapper{Handler: si}
{{- range $cb := .Callbacks }}
{{- range .Operations }}
	r.Method("{{ .Method }}", options.BaseURL+"/", http.HandlerFunc(wrapper.{{ $cb.GoName }}))
{{- end }}
{{- end }}

	return r
}

// CallbackClient makes outgoing callback HTTP requests.
// Use this from your server implementation to send callbacks.
type CallbackClient struct {
	client *http.Client
}

func NewCallbackClient(client *http.Client) *CallbackClient {
	if client == nil {
		client = http.DefaultClient
	}
	return &CallbackClient{client: client}
}
{{ range .Callbacks }}
{{- $cb := . }}
{{- range .Operations }}
// {{ $cb.GoName }} sends the {{ $cb.Name }} callback to the specified URL.
func (c *CallbackClient) {{ $cb.GoName }}(ctx context.Context, callbackURL string{{ if .RequestBody }}, body {{ .RequestBody.Type }}{{ end }}) error {
{{- if .RequestBody }}
	data, err := json.Marshal(body)
	if err != nil {
		return err
	}
	req, err := http.NewRequestWithContext(ctx, "{{ .Method }}", callbackURL, bytes.NewReader(data))
{{- else }}
	req, err := http.NewRequestWithContext(ctx, "{{ .Method }}", callbackURL, nil)
{{- end }}
	if err != nil {
		return err
	}
{{- if .RequestBody }}
	req.Header.Set("Content-Type", "application/json")
{{- end }}
	resp, err := c.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return fmt.Errorf("callback failed with status %d", resp.StatusCode)
	}
	return nil
}
{{ end }}
{{- end }}
{{- end }}
