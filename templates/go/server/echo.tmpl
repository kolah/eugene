// Code generated by eugene. DO NOT EDIT.
package {{ .Package }}

import (
{{- if .Features.HasCallbacks }}
	"bytes"
	"context"
{{- end }}
{{- if or .Features.HasStreaming .Features.HasCallbacks }}
	"encoding/json"
	"fmt"
{{- end }}
{{- if .Features.HasMultipart }}
	"mime/multipart"
{{- end }}
	"net/http"

	"github.com/labstack/echo/v4"
)
{{- if .Features.HasStreaming }}

// Writer writes Server-Sent Events to an HTTP response.
type Writer struct {
	w       http.ResponseWriter
	flusher http.Flusher
}

// NewWriter creates a Writer from an echo.Context.
func NewWriter(ctx echo.Context) (*Writer, error) {
	w := ctx.Response().Writer
	flusher, ok := w.(http.Flusher)
	if !ok {
		return nil, fmt.Errorf("streaming not supported")
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	return &Writer{w: w, flusher: flusher}, nil
}

// Send writes an event with optional type. Data is JSON-encoded.
func (w *Writer) Send(eventType string, data any) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return w.SendRaw(eventType, jsonData)
}

// SendRaw writes raw data without JSON encoding.
func (w *Writer) SendRaw(eventType string, data []byte) error {
	if eventType != "" {
		if _, err := fmt.Fprintf(w.w, "event: %s\n", eventType); err != nil {
			return err
		}
	}
	if _, err := fmt.Fprintf(w.w, "data: %s\n\n", data); err != nil {
		return err
	}
	w.flusher.Flush()
	return nil
}
{{- end }}
{{- range .Operations }}
{{- if .IsMultipart }}

type {{ .ID | pascalCase }}MultipartRequest struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }} `form:"{{ .Name }}"`
{{- end }}
}
{{- end }}
{{- if .IsFormUrlEncoded }}

type {{ .ID | pascalCase }}FormRequest struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }} `form:"{{ .Name }}"`
{{- end }}
}
{{- end }}
{{- end }}

type ServerInterface interface {
{{- range .Operations }}
	// {{ .ID | pascalCase }}{{ if .Summary }} - {{ .Summary }}{{ end }}{{ if .IsStreaming }} (streaming){{ end }}
	{{ .ID | pascalCase }}(ctx echo.Context{{ range .Parameters }}{{ if eq .In "path" }}, {{ .GoName | lower }} {{ .Type }}{{ end }}{{ end }}{{ if .HasQueryString }}, {{ .QueryString.GoName | lower }} *{{ .QueryString.Type }}{{ end }}{{ if .IsMultipart }}, req {{ .ID | pascalCase }}MultipartRequest{{ end }}{{ if .IsFormUrlEncoded }}, req {{ .ID | pascalCase }}FormRequest{{ end }}) error
{{- end }}
}

type ServerInterfaceWrapper struct {
	Handler ServerInterface
}
{{ range .Operations }}
func (w *ServerInterfaceWrapper) {{ .ID | pascalCase }}(ctx echo.Context) error {
{{- range .Parameters }}
{{- if eq .In "path" }}
	{{ .GoName | lower }} := ctx.Param("{{ .Name }}")
{{- end }}
{{- end }}
{{- if .HasQueryString }}
	var {{ .QueryString.GoName | lower }} {{ .QueryString.Type }}
	if err := ctx.Bind(&{{ .QueryString.GoName | lower }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "invalid query parameters")
	}
{{- end }}
{{- if .IsMultipart }}
	var req {{ .ID | pascalCase }}MultipartRequest
	if err := ctx.Request().ParseMultipartForm(32 << 20); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "failed to parse multipart form")
	}
{{- range .RequestBody.MultipartFields }}
{{- if .IsFile }}
{{- if .IsArray }}
	if ctx.Request().MultipartForm != nil && ctx.Request().MultipartForm.File != nil {
		req.{{ .GoName }} = ctx.Request().MultipartForm.File["{{ .Name }}"]
	}
{{- else }}
	if file, err := ctx.FormFile("{{ .Name }}"); err == nil {
		req.{{ .GoName }} = file
	}
{{- end }}
{{- else if .IsArray }}
	if ctx.Request().MultipartForm != nil && ctx.Request().MultipartForm.Value != nil {
		req.{{ .GoName }} = ctx.Request().MultipartForm.Value["{{ .Name }}"]
	}
{{- else }}
	req.{{ .GoName }} = ctx.FormValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- end }}
{{- if .IsFormUrlEncoded }}
	var req {{ .ID | pascalCase }}FormRequest
	if err := ctx.Request().ParseForm(); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "failed to parse form")
	}
{{- range .RequestBody.MultipartFields }}
{{- if .IsArray }}
	req.{{ .GoName }} = ctx.Request().Form["{{ .Name }}"]
{{- else }}
	req.{{ .GoName }} = ctx.FormValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- end }}
	return w.Handler.{{ .ID | pascalCase }}(ctx{{ range .Parameters }}{{ if eq .In "path" }}, {{ .GoName | lower }}{{ end }}{{ end }}{{ if .HasQueryString }}, &{{ .QueryString.GoName | lower }}{{ end }}{{ if .IsMultipart }}, req{{ end }}{{ if .IsFormUrlEncoded }}, req{{ end }})
}
{{ end }}
func RegisterHandlers(e *echo.Echo, si ServerInterface) {
	wrapper := &ServerInterfaceWrapper{Handler: si}
{{ range .Operations }}
{{- if eq .Method "QUERY" }}
	e.Match([]string{"QUERY"}, "{{ .FramePath }}", wrapper.{{ .ID | pascalCase }})
{{- else }}
	e.{{ .Method }}("{{ .FramePath }}", wrapper.{{ .ID | pascalCase }})
{{- end }}
{{- end }}
}

func RegisterHandlersWithBaseURL(e *echo.Echo, si ServerInterface, baseURL string) {
	wrapper := &ServerInterfaceWrapper{Handler: si}
	g := e.Group(baseURL)
{{ range .Operations }}
{{- if eq .Method "QUERY" }}
	g.Match([]string{"QUERY"}, "{{ .FramePath }}", wrapper.{{ .ID | pascalCase }})
{{- else }}
	g.{{ .Method }}("{{ .FramePath }}", wrapper.{{ .ID | pascalCase }})
{{- end }}
{{- end }}
}
{{- if .Features.HasCallbacks }}

// CallbackServerInterface handles incoming callback requests.
// Implement this interface for webhook endpoints that receive callbacks.
type CallbackServerInterface interface {
{{- range .Callbacks }}
	// {{ .GoName }} handles the {{ .Name }} callback
	{{ .GoName }}(ctx echo.Context) error
{{- end }}
}

type CallbackServerInterfaceWrapper struct {
	Handler CallbackServerInterface
}
{{ range .Callbacks }}
func (w *CallbackServerInterfaceWrapper) {{ .GoName }}(ctx echo.Context) error {
	return w.Handler.{{ .GoName }}(ctx)
}
{{ end }}
func RegisterCallbackHandlers(e *echo.Echo, si CallbackServerInterface, basePath string) {
	wrapper := &CallbackServerInterfaceWrapper{Handler: si}
	g := e.Group(basePath)
{{- range $cb := .Callbacks }}
{{- range .Operations }}
	g.{{ .Method }}("", wrapper.{{ $cb.GoName }})
{{- end }}
{{- end }}
}

// CallbackClient makes outgoing callback HTTP requests.
// Use this from your server implementation to send callbacks.
type CallbackClient struct {
	client *http.Client
}

func NewCallbackClient(client *http.Client) *CallbackClient {
	if client == nil {
		client = http.DefaultClient
	}
	return &CallbackClient{client: client}
}
{{ range .Callbacks }}
{{- $cb := . }}
{{- range .Operations }}
// {{ $cb.GoName }} sends the {{ $cb.Name }} callback to the specified URL.
func (c *CallbackClient) {{ $cb.GoName }}(ctx context.Context, callbackURL string{{ if .RequestBody }}, body {{ .RequestBody.Type }}{{ end }}) error {
{{- if .RequestBody }}
	data, err := json.Marshal(body)
	if err != nil {
		return err
	}
	req, err := http.NewRequestWithContext(ctx, "{{ .Method }}", callbackURL, bytes.NewReader(data))
{{- else }}
	req, err := http.NewRequestWithContext(ctx, "{{ .Method }}", callbackURL, nil)
{{- end }}
	if err != nil {
		return err
	}
{{- if .RequestBody }}
	req.Header.Set("Content-Type", "application/json")
{{- end }}
	resp, err := c.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return fmt.Errorf("callback failed with status %d", resp.StatusCode)
	}
	return nil
}
{{ end }}
{{- end }}
{{- end }}
