// Code generated by eugene. DO NOT EDIT.
package {{ .Package }}

import (
{{- if .Features.HasCallbacks }}
	"bytes"
	"context"
{{- end }}
	"encoding/json"
{{- if or .Features.HasStreaming .Features.HasCallbacks }}
	"fmt"
{{- end }}
{{- if .Features.HasMultipart }}
	"mime/multipart"
{{- end }}
	"net/http"
{{- if .Features.HasQueryParams }}
	"strconv"
{{- end }}
{{- if .TimeImport }}
	"time"
{{- end }}
{{- if .UUIDImport }}

	"{{ .UUIDImport }}"
{{- end }}
)
{{- range $enum := .InlineEnums }}

type {{ $enum.Name }} string

const (
{{- range $enum.Values }}
	{{ $enum.Name }}{{ . | pascalCase }} {{ $enum.Name }} = "{{ . }}"
{{- end }}
)
{{- end }}
{{- if .Features.HasStreaming }}

// Writer writes Server-Sent Events to an HTTP response.
type Writer struct {
	w       http.ResponseWriter
	flusher http.Flusher
}

// NewWriter creates a Writer from an http.ResponseWriter.
func NewWriter(w http.ResponseWriter) (*Writer, error) {
	flusher, ok := w.(http.Flusher)
	if !ok {
		return nil, fmt.Errorf("streaming not supported")
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	return &Writer{w: w, flusher: flusher}, nil
}

// Send writes an event with optional type. Data is JSON-encoded.
func (w *Writer) Send(eventType string, data any) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return w.SendRaw(eventType, jsonData)
}

// SendRaw writes raw data without JSON encoding.
func (w *Writer) SendRaw(eventType string, data []byte) error {
	if eventType != "" {
		if _, err := fmt.Fprintf(w.w, "event: %s\n", eventType); err != nil {
			return err
		}
	}
	if _, err := fmt.Fprintf(w.w, "data: %s\n\n", data); err != nil {
		return err
	}
	w.flusher.Flush()
	return nil
}
{{- end }}
{{- range .Operations }}
{{- if .IsMultipart }}

type {{ .ID | pascalCase }}MultipartRequest struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }} `form:"{{ .Name }}"`
{{- end }}
}
{{- end }}
{{- if .IsFormUrlEncoded }}

type {{ .ID | pascalCase }}FormRequest struct {
{{- range .RequestBody.MultipartFields }}
	{{ .GoName }} {{ .Type }} `form:"{{ .Name }}"`
{{- end }}
}
{{- end }}
{{- if .HasQueryParams }}

type {{ .ID | pascalCase }}QueryParams struct {
{{- range .QueryParams }}
	{{ .GoName }} {{ if not .Required }}*{{ end }}{{ .Type }}
{{- end }}
}
{{- end }}
{{- end }}

type ServerInterface interface {
{{- range .Operations }}
	// {{ .ID | pascalCase }}{{ if .Summary }} - {{ .Summary }}{{ end }}{{ if .IsStreaming }} (streaming){{ end }}
	{{ .ID | pascalCase }}(w http.ResponseWriter, r *http.Request{{ range .Parameters }}, {{ .GoName | camelCase }} {{ .Type }}{{ end }}{{ if .HasQueryParams }}, params {{ .ID | pascalCase }}QueryParams{{ end }}{{ if .HasQueryString }}, {{ .QueryString.GoName | camelCase }} *{{ .QueryString.Type }}{{ end }}{{ if .IsMultipart }}, req {{ .ID | pascalCase }}MultipartRequest{{ end }}{{ if .IsFormUrlEncoded }}, req {{ .ID | pascalCase }}FormRequest{{ end }})
{{- end }}
}

type ServerInterfaceWrapper struct {
	Handler ServerInterface
}
{{ range .Operations }}
func (w *ServerInterfaceWrapper) {{ .ID | pascalCase }}(rw http.ResponseWriter, r *http.Request) {
{{- range .Parameters }}
{{- if eq .Type "uuid.UUID" }}
	{{ .GoName | camelCase }}, err := uuid.Parse(r.PathValue("{{ .Name }}"))
	if err != nil {
		http.Error(rw, "invalid {{ .Name }}", http.StatusBadRequest)
		return
	}
{{- else }}
	{{ .GoName | camelCase }} := r.PathValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- if .HasQueryParams }}
	var params {{ .ID | pascalCase }}QueryParams
{{- range .QueryParams }}
{{- if hasPrefix .Type "[]" }}
	if values := r.URL.Query()["{{ .Name }}"]; len(values) > 0 {
		{{ if .Required }}params.{{ .GoName }} = values{{ else }}params.{{ .GoName }} = &values{{ end }}
	}
{{- else if eq .Type "string" }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		{{ if .Required }}params.{{ .GoName }} = v{{ else }}params.{{ .GoName }} = &v{{ end }}
	}
{{- else if eq .Type "int" }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		if parsed, err := strconv.Atoi(v); err == nil {
			{{ if .Required }}params.{{ .GoName }} = parsed{{ else }}params.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else if eq .Type "int64" }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			{{ if .Required }}params.{{ .GoName }} = parsed{{ else }}params.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else if eq .Type "int32" }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 32); err == nil {
			val := int32(parsed)
			{{ if .Required }}params.{{ .GoName }} = val{{ else }}params.{{ .GoName }} = &val{{ end }}
		}
	}
{{- else if eq .Type "bool" }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		if parsed, err := strconv.ParseBool(v); err == nil {
			{{ if .Required }}params.{{ .GoName }} = parsed{{ else }}params.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else if eq .Type "uuid.UUID" }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		if parsed, err := uuid.Parse(v); err == nil {
			{{ if .Required }}params.{{ .GoName }} = parsed{{ else }}params.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else }}
	if v := r.URL.Query().Get("{{ .Name }}"); v != "" {
		{{ if .Required }}typed := {{ .Type }}(v)
		params.{{ .GoName }} = typed{{ else }}typed := {{ .Type }}(v)
		params.{{ .GoName }} = &typed{{ end }}
	}
{{- end }}
{{- end }}
{{- end }}
{{- if .HasQueryString }}
	var {{ .QueryString.GoName | camelCase }} {{ .QueryString.Type }}
	if err := decodeQueryString(r, &{{ .QueryString.GoName | camelCase }}); err != nil {
		http.Error(rw, "invalid query parameters", http.StatusBadRequest)
		return
	}
{{- end }}
{{- if .IsMultipart }}
	var req {{ .ID | pascalCase }}MultipartRequest
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		http.Error(rw, "failed to parse multipart form", http.StatusBadRequest)
		return
	}
{{- range .RequestBody.MultipartFields }}
{{- if .IsFile }}
{{- if .IsArray }}
	if r.MultipartForm != nil && r.MultipartForm.File != nil {
		req.{{ .GoName }} = r.MultipartForm.File["{{ .Name }}"]
	}
{{- else }}
	if r.MultipartForm != nil && r.MultipartForm.File != nil {
		if files := r.MultipartForm.File["{{ .Name }}"]; len(files) > 0 {
			req.{{ .GoName }} = files[0]
		}
	}
{{- end }}
{{- else if .IsArray }}
	if r.MultipartForm != nil && r.MultipartForm.Value != nil {
		req.{{ .GoName }} = r.MultipartForm.Value["{{ .Name }}"]
	}
{{- else }}
	req.{{ .GoName }} = r.FormValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- end }}
{{- if .IsFormUrlEncoded }}
	var req {{ .ID | pascalCase }}FormRequest
	if err := r.ParseForm(); err != nil {
		http.Error(rw, "failed to parse form", http.StatusBadRequest)
		return
	}
{{- range .RequestBody.MultipartFields }}
{{- if .IsArray }}
	req.{{ .GoName }} = r.Form["{{ .Name }}"]
{{- else }}
	req.{{ .GoName }} = r.FormValue("{{ .Name }}")
{{- end }}
{{- end }}
{{- end }}
	w.Handler.{{ .ID | pascalCase }}(rw, r{{ range .Parameters }}, {{ .GoName | camelCase }}{{ end }}{{ if .HasQueryParams }}, params{{ end }}{{ if .HasQueryString }}, &{{ .QueryString.GoName | camelCase }}{{ end }}{{ if .IsMultipart }}, req{{ end }}{{ if .IsFormUrlEncoded }}, req{{ end }})
}
{{ end }}
{{- if .Features.HasQueryString }}
func decodeQueryString(r *http.Request, v any) error {
	data := make(map[string]any)
	for key, values := range r.URL.Query() {
		if len(values) == 1 {
			data[key] = values[0]
		} else {
			data[key] = values
		}
	}
	b, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, v)
}
{{- end }}

func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdlibServerOptions{})
}

type StdlibServerOptions struct {
	BaseURL     string
	Middlewares []func(http.Handler) http.Handler
}

func HandlerWithOptions(si ServerInterface, options StdlibServerOptions) http.Handler {
	mux := http.NewServeMux()
	wrapper := &ServerInterfaceWrapper{Handler: si}
{{ range .Operations }}
	mux.HandleFunc("{{ .Method }} "+options.BaseURL+"{{ .FramePath }}", wrapper.{{ .ID | pascalCase }})
{{- end }}

	var handler http.Handler = mux
	for i := len(options.Middlewares) - 1; i >= 0; i-- {
		handler = options.Middlewares[i](handler)
	}

	return handler
}
{{- if .Features.HasCallbacks }}

// CallbackServerInterface handles incoming callback requests.
// Implement this interface for webhook endpoints that receive callbacks.
type CallbackServerInterface interface {
{{- range .Callbacks }}
	// {{ .GoName }} handles the {{ .Name }} callback
	{{ .GoName }}(w http.ResponseWriter, r *http.Request)
{{- end }}
}

type CallbackServerInterfaceWrapper struct {
	Handler CallbackServerInterface
}
{{ range .Callbacks }}
func (w *CallbackServerInterfaceWrapper) {{ .GoName }}(rw http.ResponseWriter, r *http.Request) {
	w.Handler.{{ .GoName }}(rw, r)
}
{{ end }}
func CallbackHandler(si CallbackServerInterface) http.Handler {
	return CallbackHandlerWithOptions(si, StdlibCallbackServerOptions{})
}

type StdlibCallbackServerOptions struct {
	BaseURL     string
	Middlewares []func(http.Handler) http.Handler
}

func CallbackHandlerWithOptions(si CallbackServerInterface, options StdlibCallbackServerOptions) http.Handler {
	mux := http.NewServeMux()
	wrapper := &CallbackServerInterfaceWrapper{Handler: si}
{{- range $cb := .Callbacks }}
{{- range .Operations }}
	mux.HandleFunc("{{ .Method }} "+options.BaseURL+"/", wrapper.{{ $cb.GoName }})
{{- end }}
{{- end }}

	var handler http.Handler = mux
	for i := len(options.Middlewares) - 1; i >= 0; i-- {
		handler = options.Middlewares[i](handler)
	}

	return handler
}

// CallbackClient makes outgoing callback HTTP requests.
// Use this from your server implementation to send callbacks.
type CallbackClient struct {
	client *http.Client
}

func NewCallbackClient(client *http.Client) *CallbackClient {
	if client == nil {
		client = http.DefaultClient
	}
	return &CallbackClient{client: client}
}
{{ range .Callbacks }}
{{- $cb := . }}
{{- range .Operations }}
// {{ $cb.GoName }} sends the {{ $cb.Name }} callback to the specified URL.
func (c *CallbackClient) {{ $cb.GoName }}(ctx context.Context, callbackURL string{{ if .RequestBody }}, body {{ .RequestBody.Type }}{{ end }}) error {
{{- if .RequestBody }}
	data, err := json.Marshal(body)
	if err != nil {
		return err
	}
	req, err := http.NewRequestWithContext(ctx, "{{ .Method }}", callbackURL, bytes.NewReader(data))
{{- else }}
	req, err := http.NewRequestWithContext(ctx, "{{ .Method }}", callbackURL, nil)
{{- end }}
	if err != nil {
		return err
	}
{{- if .RequestBody }}
	req.Header.Set("Content-Type", "application/json")
{{- end }}
	resp, err := c.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return fmt.Errorf("callback failed with status %d", resp.StatusCode)
	}
	return nil
}
{{ end }}
{{- end }}
{{- end }}
