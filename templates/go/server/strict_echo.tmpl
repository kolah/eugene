// Code generated by eugene. DO NOT EDIT.
package {{ .Package }}

import (
	"net/http"
{{- if .HasQueryParams }}
	"strconv"
{{- end }}

	"github.com/labstack/echo/v4"
)

// StrictEchoHandler wraps a StrictServerInterface to handle Echo requests.
type StrictEchoHandler struct {
	ssi StrictServerInterface
}

// NewStrictHandler creates a new StrictEchoHandler.
func NewStrictHandler(ssi StrictServerInterface) *StrictEchoHandler {
	return &StrictEchoHandler{ssi: ssi}
}
{{ range .Operations }}
// {{ .ID }} handles {{ .Method }} {{ .Path }}
func (h *StrictEchoHandler) {{ .ID }}(ctx echo.Context) error {
{{- if or .PathParams .QueryParams .HeaderParams .RequestBody }}
	var request {{ .ID }}RequestObject
{{- end }}
{{- range .PathParams }}
	request.{{ .GoName }} = ctx.Param("{{ .Name }}")
{{- end }}
{{- range .QueryParams }}
{{- if hasPrefix .Type "[]" }}
	if values := ctx.QueryParams()["{{ .Name }}"]; len(values) > 0 {
		{{ if .Required }}request.{{ .GoName }} = values{{ else }}request.{{ .GoName }} = &values{{ end }}
	}
{{- else if eq .Type "string" }}
	if v := ctx.QueryParam("{{ .Name }}"); v != "" {
		request.{{ .GoName }} = {{ if not .Required }}&{{ end }}v
	}
{{- else if eq .Type "int" }}
	if v := ctx.QueryParam("{{ .Name }}"); v != "" {
		if parsed, err := strconv.Atoi(v); err == nil {
			{{ if .Required }}request.{{ .GoName }} = parsed{{ else }}request.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else if eq .Type "int64" }}
	if v := ctx.QueryParam("{{ .Name }}"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			{{ if .Required }}request.{{ .GoName }} = parsed{{ else }}request.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else if eq .Type "bool" }}
	if v := ctx.QueryParam("{{ .Name }}"); v != "" {
		if parsed, err := strconv.ParseBool(v); err == nil {
			{{ if .Required }}request.{{ .GoName }} = parsed{{ else }}request.{{ .GoName }} = &parsed{{ end }}
		}
	}
{{- else }}
	if v := ctx.QueryParam("{{ .Name }}"); v != "" {
		request.{{ .GoName }} = {{ if not .Required }}&{{ end }}v
	}
{{- end }}
{{- end }}
{{- range .HeaderParams }}
	if v := ctx.Request().Header.Get("{{ .Name }}"); v != "" {
		request.{{ .GoName }} = {{ if not .Required }}&{{ end }}v
	}
{{- end }}
{{- if .RequestBody }}
	{{ if .RequestBody.Required }}var body {{ .RequestBody.Type }}
	if err := ctx.Bind(&body); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}
	request.Body = body{{ else }}var body {{ .RequestBody.Type }}
	if err := ctx.Bind(&body); err == nil {
		request.Body = &body
	}{{ end }}
{{- end }}

	response, err := h.ssi.{{ .ID }}(ctx.Request().Context(){{ if or .PathParams .QueryParams .HeaderParams .RequestBody }}, request{{ end }})
	if err != nil {
		return err
	}

	return response.Visit{{ .ID }}ResponseObject(ctx.Response().Writer)
}
{{ end }}
// RegisterStrictHandlers registers all strict handlers with the Echo instance.
func RegisterStrictHandlers(router Router, ssi StrictServerInterface) {
	h := NewStrictHandler(ssi)
{{ range .Operations }}
{{- if eq .Method "QUERY" }}
	router.Match([]string{"QUERY"}, "{{ .FramePath }}", h.{{ .ID }})
{{- else }}
	router.{{ .Method }}("{{ .FramePath }}", h.{{ .ID }})
{{- end }}
{{- end }}
}

// RegisterStrictHandlersWithBaseURL registers all strict handlers with a base URL.
func RegisterStrictHandlersWithBaseURL(router Router, ssi StrictServerInterface, baseURL string) {
	h := NewStrictHandler(ssi)
{{ range .Operations }}
{{- if eq .Method "QUERY" }}
	router.Match([]string{"QUERY"}, baseURL+"{{ .FramePath }}", h.{{ .ID }})
{{- else }}
	router.{{ .Method }}(baseURL+"{{ .FramePath }}", h.{{ .ID }})
{{- end }}
{{- end }}
}
