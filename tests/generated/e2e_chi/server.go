// Code generated by eugene. DO NOT EDIT.
package gen

import (
	"mime/multipart"
	"net/http"

	"github.com/go-chi/chi/v5"
)

type EchoFormFormRequest struct {
	Field1 string   `form:"field1"`
	Field2 string   `form:"field2"`
	Tags   []string `form:"tags"`
}

type EchoMultipartMultipartRequest struct {
	File        *multipart.FileHeader `form:"file"`
	Description string                `form:"description"`
}

type ServerInterface interface {
	// EchoJSON
	EchoJSON(w http.ResponseWriter, r *http.Request)
	// EchoForm
	EchoForm(w http.ResponseWriter, r *http.Request, req EchoFormFormRequest)
	// EchoMultipart
	EchoMultipart(w http.ResponseWriter, r *http.Request, req EchoMultipartMultipartRequest)
	// GetItem
	GetItem(w http.ResponseWriter, r *http.Request, id string)
	// CreateResource
	CreateResource(w http.ResponseWriter, r *http.Request)
	// DeleteResource
	DeleteResource(w http.ResponseWriter, r *http.Request, id string)
	// GetSession
	GetSession(w http.ResponseWriter, r *http.Request)
	// GetSecureData
	GetSecureData(w http.ResponseWriter, r *http.Request)
	// CreateShape
	CreateShape(w http.ResponseWriter, r *http.Request)
}

type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

func (w *ServerInterfaceWrapper) EchoJSON(rw http.ResponseWriter, r *http.Request) {
	w.Handler.EchoJSON(rw, r)
}

func (w *ServerInterfaceWrapper) EchoForm(rw http.ResponseWriter, r *http.Request) {
	var req EchoFormFormRequest
	if err := r.ParseForm(); err != nil {
		http.Error(rw, "failed to parse form", http.StatusBadRequest)
		return
	}
	req.Field1 = r.FormValue("field1")
	req.Field2 = r.FormValue("field2")
	req.Tags = r.Form["tags"]
	w.Handler.EchoForm(rw, r, req)
}

func (w *ServerInterfaceWrapper) EchoMultipart(rw http.ResponseWriter, r *http.Request) {
	var req EchoMultipartMultipartRequest
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		http.Error(rw, "failed to parse multipart form", http.StatusBadRequest)
		return
	}
	if r.MultipartForm != nil && r.MultipartForm.File != nil {
		if files := r.MultipartForm.File["file"]; len(files) > 0 {
			req.File = files[0]
		}
	}
	req.Description = r.FormValue("description")
	w.Handler.EchoMultipart(rw, r, req)
}

func (w *ServerInterfaceWrapper) GetItem(rw http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	w.Handler.GetItem(rw, r, id)
}

func (w *ServerInterfaceWrapper) CreateResource(rw http.ResponseWriter, r *http.Request) {
	w.Handler.CreateResource(rw, r)
}

func (w *ServerInterfaceWrapper) DeleteResource(rw http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	w.Handler.DeleteResource(rw, r, id)
}

func (w *ServerInterfaceWrapper) GetSession(rw http.ResponseWriter, r *http.Request) {
	w.Handler.GetSession(rw, r)
}

func (w *ServerInterfaceWrapper) GetSecureData(rw http.ResponseWriter, r *http.Request) {
	w.Handler.GetSecureData(rw, r)
}

func (w *ServerInterfaceWrapper) CreateShape(rw http.ResponseWriter, r *http.Request) {
	w.Handler.CreateShape(rw, r)
}

func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	Middlewares []func(http.Handler) http.Handler
}

func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := chi.NewRouter()

	for _, m := range options.Middlewares {
		r.Use(m)
	}

	wrapper := &ServerInterfaceWrapper{Handler: si}

	r.Method("POST", options.BaseURL+"/echo/json", http.HandlerFunc(wrapper.EchoJSON))
	r.Method("POST", options.BaseURL+"/echo/form", http.HandlerFunc(wrapper.EchoForm))
	r.Method("POST", options.BaseURL+"/echo/multipart", http.HandlerFunc(wrapper.EchoMultipart))
	r.Method("GET", options.BaseURL+"/items/{id}", http.HandlerFunc(wrapper.GetItem))
	r.Method("POST", options.BaseURL+"/resources", http.HandlerFunc(wrapper.CreateResource))
	r.Method("DELETE", options.BaseURL+"/resources/{id}", http.HandlerFunc(wrapper.DeleteResource))
	r.Method("GET", options.BaseURL+"/session", http.HandlerFunc(wrapper.GetSession))
	r.Method("GET", options.BaseURL+"/secure/data", http.HandlerFunc(wrapper.GetSecureData))
	r.Method("POST", options.BaseURL+"/shapes", http.HandlerFunc(wrapper.CreateShape))

	return r
}
