// Code generated by eugene. DO NOT EDIT.
package gen

import (
	"mime/multipart"
	"net/http"
)

type EchoFormFormRequest struct {
	Field1 string   `form:"field1"`
	Field2 string   `form:"field2"`
	Tags   []string `form:"tags"`
}

type EchoMultipartMultipartRequest struct {
	File        *multipart.FileHeader `form:"file"`
	Description string                `form:"description"`
}

type ServerInterface interface {
	// EchoJSON
	EchoJSON(w http.ResponseWriter, r *http.Request)
	// EchoForm
	EchoForm(w http.ResponseWriter, r *http.Request, req EchoFormFormRequest)
	// EchoMultipart
	EchoMultipart(w http.ResponseWriter, r *http.Request, req EchoMultipartMultipartRequest)
	// GetItem
	GetItem(w http.ResponseWriter, r *http.Request, id string)
	// CreateResource
	CreateResource(w http.ResponseWriter, r *http.Request)
	// DeleteResource
	DeleteResource(w http.ResponseWriter, r *http.Request, id string)
	// GetSession
	GetSession(w http.ResponseWriter, r *http.Request)
	// GetSecureData
	GetSecureData(w http.ResponseWriter, r *http.Request)
	// CreateShape
	CreateShape(w http.ResponseWriter, r *http.Request)
}

type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

func (w *ServerInterfaceWrapper) EchoJSON(rw http.ResponseWriter, r *http.Request) {
	w.Handler.EchoJSON(rw, r)
}

func (w *ServerInterfaceWrapper) EchoForm(rw http.ResponseWriter, r *http.Request) {
	var req EchoFormFormRequest
	if err := r.ParseForm(); err != nil {
		http.Error(rw, "failed to parse form", http.StatusBadRequest)
		return
	}
	req.Field1 = r.FormValue("field1")
	req.Field2 = r.FormValue("field2")
	req.Tags = r.Form["tags"]
	w.Handler.EchoForm(rw, r, req)
}

func (w *ServerInterfaceWrapper) EchoMultipart(rw http.ResponseWriter, r *http.Request) {
	var req EchoMultipartMultipartRequest
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		http.Error(rw, "failed to parse multipart form", http.StatusBadRequest)
		return
	}
	if r.MultipartForm != nil && r.MultipartForm.File != nil {
		if files := r.MultipartForm.File["file"]; len(files) > 0 {
			req.File = files[0]
		}
	}
	req.Description = r.FormValue("description")
	w.Handler.EchoMultipart(rw, r, req)
}

func (w *ServerInterfaceWrapper) GetItem(rw http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	w.Handler.GetItem(rw, r, id)
}

func (w *ServerInterfaceWrapper) CreateResource(rw http.ResponseWriter, r *http.Request) {
	w.Handler.CreateResource(rw, r)
}

func (w *ServerInterfaceWrapper) DeleteResource(rw http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	w.Handler.DeleteResource(rw, r, id)
}

func (w *ServerInterfaceWrapper) GetSession(rw http.ResponseWriter, r *http.Request) {
	w.Handler.GetSession(rw, r)
}

func (w *ServerInterfaceWrapper) GetSecureData(rw http.ResponseWriter, r *http.Request) {
	w.Handler.GetSecureData(rw, r)
}

func (w *ServerInterfaceWrapper) CreateShape(rw http.ResponseWriter, r *http.Request) {
	w.Handler.CreateShape(rw, r)
}

func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdlibServerOptions{})
}

type StdlibServerOptions struct {
	BaseURL     string
	Middlewares []func(http.Handler) http.Handler
}

func HandlerWithOptions(si ServerInterface, options StdlibServerOptions) http.Handler {
	mux := http.NewServeMux()
	wrapper := &ServerInterfaceWrapper{Handler: si}

	mux.HandleFunc("POST "+options.BaseURL+"/echo/json", wrapper.EchoJSON)
	mux.HandleFunc("POST "+options.BaseURL+"/echo/form", wrapper.EchoForm)
	mux.HandleFunc("POST "+options.BaseURL+"/echo/multipart", wrapper.EchoMultipart)
	mux.HandleFunc("GET "+options.BaseURL+"/items/{id}", wrapper.GetItem)
	mux.HandleFunc("POST "+options.BaseURL+"/resources", wrapper.CreateResource)
	mux.HandleFunc("DELETE "+options.BaseURL+"/resources/{id}", wrapper.DeleteResource)
	mux.HandleFunc("GET "+options.BaseURL+"/session", wrapper.GetSession)
	mux.HandleFunc("GET "+options.BaseURL+"/secure/data", wrapper.GetSecureData)
	mux.HandleFunc("POST "+options.BaseURL+"/shapes", wrapper.CreateShape)

	var handler http.Handler = mux
	for i := len(options.Middlewares) - 1; i >= 0; i-- {
		handler = options.Middlewares[i](handler)
	}

	return handler
}
