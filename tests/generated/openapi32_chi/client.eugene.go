// Code generated by eugene. DO NOT EDIT.
package gen

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type Client struct {
	baseURL    string
	httpClient *http.Client
}

type ClientOption func(*Client)

func WithHTTPClient(client *http.Client) ClientOption {
	return func(c *Client) {
		c.httpClient = client
	}
}

func NewClient(baseURL string, opts ...ClientOption) *Client {
	c := &Client{
		baseURL:    strings.TrimSuffix(baseURL, "/"),
		httpClient: http.DefaultClient,
	}
	for _, opt := range opts {
		opt(c)
	}
	return c
}

type Response[T any] struct {
	StatusCode int
	Body       T
	Raw        *http.Response
}

func encodeQueryString(v any) string {
	q := url.Values{}
	encodeValue(q, "", v)
	return q.Encode()
}

func encodeValue(q url.Values, prefix string, v any) {
	switch val := v.(type) {
	case nil:
		return
	case string:
		q.Set(prefix, val)
	case int, int32, int64, float32, float64, bool:
		q.Set(prefix, fmt.Sprint(val))
	case []any:
		for i, item := range val {
			key := prefix
			if prefix != "" {
				key = fmt.Sprintf("%s[%d]", prefix, i)
			}
			encodeValue(q, key, item)
		}
	case map[string]any:
		for k, item := range val {
			key := k
			if prefix != "" {
				key = fmt.Sprintf("%s[%s]", prefix, k)
			}
			encodeValue(q, key, item)
		}
	default:
		q.Set(prefix, fmt.Sprint(val))
	}
}

// ServerEvent represents a Server-Sent Event.
type ServerEvent struct {
	Type string // event type from "event:" field
	Data []byte // event data from "data:" field
	ID   string // event ID from "id:" field
}

// Decode unmarshals the event data into the provided value.
func (e *ServerEvent) Decode(v any) error {
	return json.Unmarshal(e.Data, v)
}

// EventStream reads Server-Sent Events from an HTTP response.
// Use Next() to advance, Current() to get the event, Err() to check errors.
type EventStream struct {
	resp    *http.Response
	scanner *bufio.Scanner
	current *ServerEvent
	err     error
}

func newEventStream(resp *http.Response) *EventStream {
	return &EventStream{
		resp:    resp,
		scanner: bufio.NewScanner(resp.Body),
	}
}

// Next advances to the next event. Returns false when stream ends or on error.
func (s *EventStream) Next() bool {
	if s.err != nil {
		return false
	}

	event := &ServerEvent{}
	var data []byte

	for s.scanner.Scan() {
		line := s.scanner.Bytes()

		if len(line) == 0 {
			// Empty line = end of event
			if len(data) > 0 {
				event.Data = bytes.TrimSuffix(data, []byte("\n"))
				s.current = event
				return true
			}
			continue
		}

		switch {
		case bytes.HasPrefix(line, []byte("event:")):
			event.Type = string(bytes.TrimSpace(line[6:]))
		case bytes.HasPrefix(line, []byte("data:")):
			data = append(data, bytes.TrimSpace(line[5:])...)
			data = append(data, '\n')
		case bytes.HasPrefix(line, []byte("id:")):
			event.ID = string(bytes.TrimSpace(line[3:]))
		}
	}

	// Handle final event without trailing newline
	if len(data) > 0 {
		event.Data = bytes.TrimSuffix(data, []byte("\n"))
		s.current = event
		return true
	}

	s.err = s.scanner.Err()
	return false
}

// Current returns the most recent event from Next().
func (s *EventStream) Current() *ServerEvent {
	return s.current
}

// Err returns the error that stopped iteration, if any.
// Returns nil on normal EOF.
func (s *EventStream) Err() error {
	return s.err
}

// Close closes the underlying response body.
func (s *EventStream) Close() error {
	return s.resp.Body.Close()
}

func doStreamRequest(ctx context.Context, c *Client, method, path string, body any) (*EventStream, error) {
	var bodyReader io.Reader
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("marshaling request body: %w", err)
		}
		bodyReader = bytes.NewReader(data)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	req.Header.Set("Accept", "text/event-stream")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}

	if resp.StatusCode >= 400 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		resp.Body.Close()
		return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return newEventStream(resp), nil
}

func doRequest[T any](ctx context.Context, c *Client, method, path string, body any) (*Response[T], error) {
	var bodyReader io.Reader
	if body != nil {
		data, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("marshaling request body: %w", err)
		}
		bodyReader = bytes.NewReader(data)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &Response[T]{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	if resp.StatusCode >= 400 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	if resp.ContentLength != 0 {
		if err := json.NewDecoder(resp.Body).Decode(&result.Body); err != nil && err != io.EOF {
			return result, fmt.Errorf("decoding response: %w", err)
		}
	}

	return result, nil
}

// SearchItemsResponse contains typed response data for SearchItems.
type SearchItemsResponse struct {
	StatusCode int
	JSON200    *[]SearchResult
	Raw        *http.Response
}

// ListItemsResponse contains typed response data for ListItems.
type ListItemsResponse struct {
	StatusCode int
	JSON200    *[]Item
	Raw        *http.Response
}

// StreamJsonlResponse contains typed response data for StreamJsonl.
type StreamJsonlResponse struct {
	StatusCode int
	JSON200    *any
	Raw        *http.Response
}

// AdvancedSearchResponse contains typed response data for AdvancedSearch.
type AdvancedSearchResponse struct {
	StatusCode int
	JSON200    *[]SearchResult
	Raw        *http.Response
}

// SearchItems - Search using QUERY method
func (c *Client) SearchItems(ctx context.Context, body SearchQuery) (*SearchItemsResponse, error) {
	path := "/search"

	var bodyReader io.Reader
	var contentType string
	data, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshaling request body: %w", err)
	}
	bodyReader = bytes.NewReader(data)
	contentType = "application/json"

	httpReq, err := http.NewRequestWithContext(ctx, "QUERY", c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}
	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}
	httpReq.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &SearchItemsResponse{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, fmt.Errorf("reading response: %w", err)
	}

	switch resp.StatusCode {
	case 200:
		var body []SearchResult
		if len(bodyBytes) > 0 {
			if err := json.Unmarshal(bodyBytes, &body); err != nil {
				return result, fmt.Errorf("decoding response: %w", err)
			}
		}
		result.JSON200 = &body
	}

	if resp.StatusCode >= 400 {
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return result, nil
}

// StreamEvents - Stream events via SSE (streaming)
func (c *Client) StreamEvents(ctx context.Context) (*EventStream, error) {
	path := "/events"
	return doStreamRequest(ctx, c, "GET", path, nil)
}

// ListItems - List items with query parameter
func (c *Client) ListItems(ctx context.Context, params *ListItemsParams) (*ListItemsResponse, error) {
	path := "/items"
	if params != nil {
		q := url.Values{}
		if params.Filter != nil {
			q.Set("filter", fmt.Sprint(*params.Filter))
		}
		if len(q) > 0 {
			path += "?" + q.Encode()
		}
	}

	var bodyReader io.Reader

	httpReq, err := http.NewRequestWithContext(ctx, "GET", c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}
	httpReq.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &ListItemsResponse{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, fmt.Errorf("reading response: %w", err)
	}

	switch resp.StatusCode {
	case 200:
		var body []Item
		if len(bodyBytes) > 0 {
			if err := json.Unmarshal(bodyBytes, &body); err != nil {
				return result, fmt.Errorf("decoding response: %w", err)
			}
		}
		result.JSON200 = &body
	}

	if resp.StatusCode >= 400 {
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return result, nil
}

// StreamSse - Stream data via SSE with itemSchema (streaming)
func (c *Client) StreamSse(ctx context.Context) (*EventStream, error) {
	path := "/stream/sse"
	return doStreamRequest(ctx, c, "GET", path, nil)
}

// StreamJsonl - Stream data via JSON Lines
func (c *Client) StreamJsonl(ctx context.Context) (*StreamJsonlResponse, error) {
	path := "/stream/jsonl"

	var bodyReader io.Reader

	httpReq, err := http.NewRequestWithContext(ctx, "GET", c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}
	httpReq.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &StreamJsonlResponse{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, fmt.Errorf("reading response: %w", err)
	}

	switch resp.StatusCode {
	case 200:
		var body any
		if len(bodyBytes) > 0 {
			if err := json.Unmarshal(bodyBytes, &body); err != nil {
				return result, fmt.Errorf("decoding response: %w", err)
			}
		}
		result.JSON200 = &body
	}

	if resp.StatusCode >= 400 {
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return result, nil
}

// AdvancedSearch - Advanced search using querystring parameter
func (c *Client) AdvancedSearch(ctx context.Context, query *AdvancedSearchQuery) (*AdvancedSearchResponse, error) {
	path := "/advanced-search"
	if query != nil {
		path += "?" + encodeQueryString(query)
	}

	var bodyReader io.Reader

	httpReq, err := http.NewRequestWithContext(ctx, "GET", c.baseURL+path, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}
	httpReq.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	result := &AdvancedSearchResponse{
		StatusCode: resp.StatusCode,
		Raw:        resp,
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, fmt.Errorf("reading response: %w", err)
	}

	switch resp.StatusCode {
	case 200:
		var body []SearchResult
		if len(bodyBytes) > 0 {
			if err := json.Unmarshal(bodyBytes, &body); err != nil {
				return result, fmt.Errorf("decoding response: %w", err)
			}
		}
		result.JSON200 = &body
	}

	if resp.StatusCode >= 400 {
		return result, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	return result, nil
}

type ListItemsParams struct {
	Filter *string
}
