// Code generated by eugene. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
)

// Writer writes Server-Sent Events to an HTTP response.
type Writer struct {
	w       http.ResponseWriter
	flusher http.Flusher
}

// NewWriter creates a Writer from an echo.Context.
func NewWriter(ctx echo.Context) (*Writer, error) {
	w := ctx.Response().Writer
	flusher, ok := w.(http.Flusher)
	if !ok {
		return nil, fmt.Errorf("streaming not supported")
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	return &Writer{w: w, flusher: flusher}, nil
}

// Send writes an event with optional type. Data is JSON-encoded.
func (w *Writer) Send(eventType string, data any) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return w.SendRaw(eventType, jsonData)
}

// SendRaw writes raw data without JSON encoding.
func (w *Writer) SendRaw(eventType string, data []byte) error {
	if eventType != "" {
		if _, err := fmt.Fprintf(w.w, "event: %s\n", eventType); err != nil {
			return err
		}
	}
	if _, err := fmt.Fprintf(w.w, "data: %s\n\n", data); err != nil {
		return err
	}
	w.flusher.Flush()
	return nil
}

type ListItemsQueryParams struct {
	Filter *string `query:"filter"`
}

type ServerInterface interface {
	// SearchItems - Search using QUERY method
	SearchItems(ctx echo.Context) error
	// StreamEvents - Stream events via SSE (streaming)
	StreamEvents(ctx echo.Context) error
	// ListItems - List items with query parameter
	ListItems(ctx echo.Context, params ListItemsQueryParams) error
	// StreamSse - Stream data via SSE with itemSchema (streaming)
	StreamSse(ctx echo.Context) error
	// StreamJsonl - Stream data via JSON Lines
	StreamJsonl(ctx echo.Context) error
	// AdvancedSearch - Advanced search using querystring parameter
	AdvancedSearch(ctx echo.Context, query *AdvancedSearchQuery) error
}

type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

func (w *ServerInterfaceWrapper) SearchItems(ctx echo.Context) error {
	return w.Handler.SearchItems(ctx)
}

func (w *ServerInterfaceWrapper) StreamEvents(ctx echo.Context) error {
	return w.Handler.StreamEvents(ctx)
}

func (w *ServerInterfaceWrapper) ListItems(ctx echo.Context) error {
	var params ListItemsQueryParams
	if err := ctx.Bind(&params); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "invalid query parameters")
	}
	return w.Handler.ListItems(ctx, params)
}

func (w *ServerInterfaceWrapper) StreamSse(ctx echo.Context) error {
	return w.Handler.StreamSse(ctx)
}

func (w *ServerInterfaceWrapper) StreamJsonl(ctx echo.Context) error {
	return w.Handler.StreamJsonl(ctx)
}

func (w *ServerInterfaceWrapper) AdvancedSearch(ctx echo.Context) error {
	var query AdvancedSearchQuery
	if err := ctx.Bind(&query); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "invalid query parameters")
	}
	return w.Handler.AdvancedSearch(ctx, &query)
}

func RegisterHandlers(router Router, si ServerInterface) {
	wrapper := &ServerInterfaceWrapper{Handler: si}

	router.Match([]string{"QUERY"}, "/search", wrapper.SearchItems)
	router.GET("/events", wrapper.StreamEvents)
	router.GET("/items", wrapper.ListItems)
	router.GET("/stream/sse", wrapper.StreamSse)
	router.GET("/stream/jsonl", wrapper.StreamJsonl)
	router.GET("/advanced-search", wrapper.AdvancedSearch)
}

func RegisterHandlersWithBaseURL(router Router, si ServerInterface, baseURL string) {
	wrapper := &ServerInterfaceWrapper{Handler: si}

	router.Match([]string{"QUERY"}, baseURL+"/search", wrapper.SearchItems)
	router.GET(baseURL+"/events", wrapper.StreamEvents)
	router.GET(baseURL+"/items", wrapper.ListItems)
	router.GET(baseURL+"/stream/sse", wrapper.StreamSse)
	router.GET(baseURL+"/stream/jsonl", wrapper.StreamJsonl)
	router.GET(baseURL+"/advanced-search", wrapper.AdvancedSearch)
}
